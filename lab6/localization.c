#pragma config(Sensor, S1,     sonarSensor,    sensorSONAR)
#pragma config(Sensor, S2,     lightSensor,    sensorLightActive)
#pragma config(Motor,  motorA,          motorRight,    tmotorNXT, PIDControl, driveRight, encoder)
#pragma config(Motor,  motorB,           ,             tmotorNXT, openLoop)
#pragma config(Motor,  motorC,          motorLeft,     tmotorNXT, PIDControl, driveLeft, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/**********************************************
* Lab 3 : Starter code
* Written by Kaushik Viswanathan,
* Modified by Allan Wang (Jan 2017)

* Feel free to modify any part of these codes.
**********************************************/

// Ground truth map vector, clockwise
const char map[16] = {0, 1, 0, 0, 1, 1, 1, 0, 0, 1, 0, 0, 0, 1, 0, 1};
// The goal section to go to
const int goal_sec = 4;
// Set this to 32 for two loops of configuration in challenge mode
const int CONFIG_COUNT = 32;

// Robot's belief of where it started
float belief[16] = {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0};
// Robot's recording of where it saw walls in the last run
int wall[16] = {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0};

// Number of sections we have passed
int sec_count = 0;

//Set parameters
const float WALL_RADIUS = 21; // The radius of the circle the walls stand on
const int THRESHOLD = 40; // Threshold for line follinwg, below this value considered black line
const float SONAR_THRESHOLD = 30; // Sonar readings below this value is considered a wall
const int MOTOR_POWER = 35;	 //Base motor power to control the speed
const int UPDATE_INTERVAL = 1; //Delay updates by x miliseconds
const float WALL_WIDTH = 6/(2*PI*WALL_RADIUS); // The projection of wall onto the path in radians

//Robot's positions
float robot_X = 12, robot_Y = 0.0, robot_TH = PI/2, robot_PHI = 0.0;
int last_sec, curr_sec;
float last_TH;

int velocityUpdateInterval = 1;

// Flags
bool configured = false;
bool done = false;

//Wheel diameter and circumference in inch
const float WHEEL_DIAMETER = 2.175;
const float WHEEL_CIRCUMFERENCE = WHEEL_DIAMETER * PI;
//Distance between wheels in inch
const float WHEEL_DISTANCE = 6.5;
//Number of ticks per inch
const float TICKS_PER_INCH = 360/WHEEL_CIRCUMFERENCE;

task dead_reckoning()
{
	clearTimer(T1);
	clearTimer(T2);

	bool init_enc = true;
	float last_enc_L, last_enc_R;

	// Flags used for starting section configuration
	bool seen_gap = false;
	bool seen_wall = false;

	// Ready to head home
	bool homestretch = false;

	// The half angle-width of the
	float goal_TH;

	while(1)
	{
		//
		// Dead Reckoning
		//

		if(time1[T2] < 4000)
		{
			continue;
		}
		else if(init_enc)
		{
			nMotorEncoder[motorRight] = 0;
			nMotorEncoder[motorLeft] = 0;
			last_enc_L = nMotorEncoder[motorLeft];
			last_enc_R = nMotorEncoder[motorRight];
			init_enc = false;
		}

		int dt = time1[T1];
		if(dt == 0)
		{
			continue;
		}
		clearTimer(T1);

		int dEncL = nMotorEncoder[motorLeft] - last_enc_L;
		int dEncR = nMotorEncoder[motorRight] - last_enc_R;
		last_enc_L = nMotorEncoder[motorLeft];
		last_enc_R = nMotorEncoder[motorRight];

		//update robot_x and robot_Y
		float dispL = dEncL / TICKS_PER_INCH;
		float dispR = dEncR / TICKS_PER_INCH;
		float disp = (dispL + dispR)/2;
		float angDisp = (dispL - dispR)/WHEEL_DISTANCE;
		robot_TH = robot_TH + angDisp/2;
		robot_X = robot_X + cos(robot_TH)*disp;
		robot_Y = robot_Y + sin(robot_TH)*disp;
		robot_TH = robot_TH + angDisp/2;

		if(robot_TH> 2*PI)
		{
			robot_TH = robot_TH - 2*PI;
		}

		robot_PHI = atan2(robot_Y, robot_X);

		nxtDisplayTextLine(0, "t: %f", robot_TH / PI * 180);

		// Get sonar readings
		bool isWall = SensorValue[S1] <= SONAR_THRESHOLD;

		if(curr_sec < 0){
			curr_sec += 16;
		}

		if (!configured){ //We need to determine whether we are in the middle of the map

			nxtDisplayTextLine(2, "Goal: %f", goal_TH * 180/PI);
			if (!seen_gap && !isWall){ //We are ready to look for the first wall
				seen_gap = true;
				playSound(soundDownwardTones);
			}
			else if (isWall && !seen_wall){ //We see our first wall, wait a bit to be in the middle of the section
				goal_TH = robot_TH + WALL_WIDTH*4.7;
				if (goal_TH > 2*PI){
					goal_TH -= 2*PI;
				}
				seen_wall = true;
			}
			else if (seen_wall){ //We are ready to start localizing, we are supposed to be in the middle of a section
				if (robot_TH > goal_TH){
					playSound(soundException);
					configured = true;
					robot_Y = 0;
					robot_X = 12;
					robot_TH = PI/2;
					last_TH = robot_TH - PI/4;
					last_sec = -2;
					curr_sec = -1;
				}
			}
		}
		else{ //We are configured
			if(abs(robot_TH - last_TH) > PI/8){ //We have moved one section
				curr_sec = (curr_sec + 1)%16;
				sec_count += 1;
				if(sec_count >= CONFIG_COUNT && !homestretch){ //Completed localization, get current sec
					playSound(soundFastUpwardTones);
					homestretch = true;
					int belief_sec = 0; // where we think we currently are
					int maxBelief = 0;
					for(int i = 0; i < 16; i++){
						if(belief[i] > maxBelief){ //The highest belief indicates our starting position
							maxBelief = belief[i];
							belief_sec = (i + curr_sec)%16; // Offset by our dead reckoning to get current position
						}
					}
					curr_sec = belief_sec;
				}
				if(homestretch){
					done = curr_sec == goal_sec;
				}
				last_TH = robot_TH;

				nxtDisplayTextLine(4, "Current: %d", curr_sec);
				playSound(soundBlip);
				if(!homestretch){
					if(isWall){
						wall[curr_sec] = 1;
						playSound(soundBlip);
					}
					else{
						wall[curr_sec] = 0;
					}
					for (int i = 0; i < 16; i++){
						if ((map[i] == 1 && isWall) || (map[i] == 0 && !isWall)){
							int ind1 = (i-curr_sec-1)%16;
							int ind2 = (i-curr_sec)%16;
							int ind3 = (i-curr_sec+1)%16;
							if(ind1 < 0){
								ind1 += 16;
							}
							if(ind2 < 0){
								ind2 += 16;
							}
							if(ind3 < 0){
								ind3 += 16;
							}
							belief[ind1] += 0.5;
							belief[ind2] += 1;
							belief[ind3] += 0.5;
						}
					}
				}
			}
		}
		wait1Msec(velocityUpdateInterval);
	}
}



/*****************************************
* Main function - Needs changing
*****************************************/

task main()
{
	//Wait for sensor initialization
	wait1Msec(50);

	clearTimer(T1);

	float feedforward   = .3*MOTOR_POWER;
	float additional_ff = .9*MOTOR_POWER;

	startTask(dead_reckoning);

	// Start line following
	while(1){

		if(SensorValue[S2] < THRESHOLD){ // Seeing the black line
			motor[motorRight]  = MOTOR_POWER;
			motor[motorLeft] = MOTOR_POWER + feedforward;
		}
		else{ // Seeing the white line
			motor[motorRight]  = MOTOR_POWER - additional_ff/2;
			motor[motorLeft] = MOTOR_POWER + feedforward + additional_ff/2;
		}
		if(done)
		{
			motor[motorLeft]  = 0;
			motor[motorRight] = 0;
			return;
		}
		wait1Msec(UPDATE_INTERVAL);
	}
}
