#pragma config(Sensor, S1,     sonarSensor,    sensorSONAR)
#pragma config(Sensor, S2,     lightSensor,    sensorLightActive)
#pragma config(Motor,  motorA,          motorRight,    tmotorNXT, PIDControl, driveRight, encoder)
#pragma config(Motor,  motorB,           ,             tmotorNXT, openLoop)
#pragma config(Motor,  motorC,          motorLeft,     tmotorNXT, PIDControl, driveLeft, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/**********************************************
* Lab 3 : Starter code
* Written by Kaushik Viswanathan,
* Modified by Allan Wang (Jan 2017)

* Feel free to modify any part of these codes.
**********************************************/

// Map setup
const char map[16] = {0, 1, 1, 0, 1, 0, 1, 0, 0, 1, 0, 0, 1, 1, 1, 0};

float belief[16] = {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0};
int wall[16] = {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0};

//Set parameters
const float WALL_RADIUS = 21;
const int THRESHOLD = 40;
const float SONAR_THRESHOLD = 35;
const int MOTOR_POWER = 30;	 //Base motor power to control the speed
const int UPDATE_INTERVAL = 1; //Delay updates by x miliseconds
const float WALL_WIDTH = 6/(2*PI*WALL_RADIUS);

//Robot's positions
float robot_X = 12, robot_Y = 0.0, robot_TH = PI/2, robot_PHI = 0.0;
int last_sec, curr_sec;
float last_TH;

int velocityUpdateInterval = 1;

// Flags
	bool configured = false;

//Wheel diameter and circumference in inch
const float WHEEL_DIAMETER = 2.18;
const float WHEEL_CIRCUMFERENCE = WHEEL_DIAMETER * PI;
//Distance between wheels in inch
const float WHEEL_DISTANCE = 6.5;
//Number of ticks per inch
const float TICKS_PER_INCH = 360/WHEEL_CIRCUMFERENCE;

int count = 0;
bool equals(float val, float target, float epsilon){
	return abs(val - target) <= epsilon;
}

task dead_reckoning()
{
	clearTimer(T1);
	clearTimer(T2);

	bool init_enc = true;
	float last_enc_L, last_enc_R;

	bool seen_gap = false;
	bool seen_wall = false;
	bool homestretch = false;

	float goal_TH;

	while(1)
	{
		//
		// Dead Reckoning
		//

		if(time1[T2] < 2000)
		{
			continue;
		}
		else if(init_enc)
		{
			nMotorEncoder[motorRight] = 0;
			nMotorEncoder[motorLeft] = 0;
			last_enc_L = nMotorEncoder[motorLeft];
			last_enc_R = nMotorEncoder[motorRight];
			init_enc = false;
		}

		int dt = time1[T1];
		if(dt == 0)
		{
			continue;
		}
		clearTimer(T1);

		int dEncL = nMotorEncoder[motorLeft] - last_enc_L;
		int dEncR = nMotorEncoder[motorRight] - last_enc_R;
		last_enc_L = nMotorEncoder[motorLeft];
		last_enc_R = nMotorEncoder[motorRight];

		//update robot_x and robot_Y
		float dispL = dEncL / TICKS_PER_INCH;
		float dispR = dEncR / TICKS_PER_INCH;
		float disp = (dispL + dispR)/2;
		float angDisp = (dispR - dispL)/WHEEL_DISTANCE;
		robot_TH = robot_TH + angDisp/2;
		robot_X = robot_X + cos(robot_TH)*disp;
		robot_Y = robot_Y + sin(robot_TH)*disp;
		robot_TH = robot_TH + angDisp/2;

		if(robot_TH> 2*PI)
		{
			robot_TH = robot_TH - 2*PI;
		}

		robot_PHI = atan2(robot_Y, robot_X);

		nxtDisplayTextLine(0, "t: %f", robot_TH / PI * 180);

		// Get sonar readings
		bool isWall = SensorValue[S1] <= SONAR_THRESHOLD;

		if(curr_sec < 0){
			curr_sec += 16;
		}

		if (!configured){

			nxtDisplayTextLine(2, "Goal: %f", goal_TH * 180/PI);
			if (!seen_gap && !isWall){
				seen_gap = true;
				playSound(soundBlip);
			}
			else if (isWall && !seen_wall){
				goal_TH = robot_TH + WALL_WIDTH*2.5;
				if (goal_TH > 2*PI){
					goal_TH -= 2*PI;
				}
				seen_wall = true;
			}
			else if (seen_wall){
				if (robot_TH > goal_TH){
					playSound(soundException);
					configured = true;
					robot_Y = 0;
					robot_X = 12;
					robot_TH = PI/2;
					last_TH = robot_TH - PI/4;
					curr_sec = 0;
				}
			}
		}
		if (configured){ //We are configured

			if(abs(robot_TH - last_TH) > PI/8){ //We have moved one section
				curr_sec = (curr_sec + 1)%16;
				last_TH = robot_TH;
				count += 1;

				nxtDisplayTextLine(3, "Last: %d", last_sec);
				nxtDisplayTextLine(4, "Current: %d", curr_sec);
				nxtDisplayTextLine(6, "Count %d", count);
				playSound(soundBlip);
				if(isWall){
					wall[curr_sec] = 1;
				}
				else{
					wall[curr_sec] = 0;
				}

				for (int i = 0; i < 16; i++){
					if ((map[i] == 1 && isWall) || (map[i] == 0 && !isWall)){
						int index = (i-curr_sec);
						if(index < 0){
							index += 16;
						}
						belief[index] += 1;
					}
				}
			}

		}
		wait1Msec(velocityUpdateInterval);
	}
}



/*****************************************
* Main function - Needs changing
*****************************************/

task main()
{
	//Wait for sensor initialization
	wait1Msec(50);

	clearTimer(T1);

	float feedforward = .3*MOTOR_POWER;
	float additional_ff = .8*MOTOR_POWER;
	// Find the line by turning left, then if line is not found within angle, turn right
	while(SensorValue[S2] >= THRESHOLD ){
		nxtDisplayTextLine(0, "Searching");
			motor[motorLeft] = -1*MOTOR_POWER;
			motor[motorRight] = MOTOR_POWER;
	}
	startTask(dead_reckoning);

	// Start line following
	while(1){

		if(SensorValue[S2] < THRESHOLD){ // Seeing the black line
			motor[motorLeft] = MOTOR_POWER;
			motor[motorRight] = MOTOR_POWER+feedforward;
		}
		else{
			motor[motorLeft] = MOTOR_POWER -additional_ff/2;
			motor[motorRight] = MOTOR_POWER +feedforward+additional_ff/2;
		}
		if(equals(robot_TH, PI/2- 0.015, 0.01))
		{
			motor[motorRight] = 0;
			motor[motorLeft] = 0; //Left Motor
			return;
		}
		wait1Msec(UPDATE_INTERVAL);
	}
}
