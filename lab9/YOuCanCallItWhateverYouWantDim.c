#pragma config(Motor,  motorA,          joint1,        tmotorNXT, PIDControl, reversed, encoder)
#pragma config(Motor,  motorB,          joint2,        tmotorNXT, PIDControl, reversed, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

int wpth1[3][6] = {};
int wpth2[3][6] = {};
int num_waypoints = 6;

int joint1Strength = 4;
int joint2Strength = 5;
task main()
{
	nMotorEncoder[joint1] = 0;
	nMotorEncoder[joint2] = 0;
	for(int j = 0; j<3; j++)
	{
		for(int i = 0; i < num_waypoints; i++)
		{
			int goalth1 = wpth1[j][i];
			int goalth2 = wpth2[j][i];

			int errorth1 = goalth1 - nMotorEncoder[joint1];
			int lastErrorth1 = goalth1 - nMotorEncoder[joint1];
			int sumErrorth1 = 0;

			int errorth2 = goalth2 - nMotorEncoder[joint2];
			int lastErrorth2 = goalth2 - nMotorEncoder[joint2];
			int sumErrorth2 = 0;
			clearTimer(T1);

			while(errorth1 > 1 && errorth2 > 1)
			{

				int dt = time1[T1];

				if(dt == 0){
					continue;
				}
				clearTimer(T1);

				errorth1 = goalth1 - nMotorEncoder[joint1];
				errorth2 = goalth2 - nMotorEncoder[joint2];

				float d_errorth1 = (errorth1-lastErrorth1)/dt;
				float d_errorth2 = (errorth2-lastErrorth2)/dt;

				sumErrorth1 += errorth1;
				sumErrorth2 += errorth2;

				lastErrorth1 = errorth1;
				lastErrorth2 = errorth2;

				float kP1 = 0.0;
				float kD1 = 0.0;
				float kI1 = 0.0;

				float kP2 = 0.0;
				float kD2 = 0.0;
				float kI2 = 0.0;

				float signalJ1 = kP1 * errorth1 + kD1 * d_errorth1 + kI1 * sumErrorth1;
				float signalJ2 = kP2 * errorth2 + kD2 * d_errorth2 + kI2 * sumErrorth2;

				int feedforwardJ1 = cos(nMotorEncoder[joint1]);
				int feedforwardJ2 = cos(nMotorEncoder[joint2]);

				int inputJ1 = signalJ1 * joint1Strength + feedforwardJ1;
				int inputJ2 = signalJ2 * joint2Strength + feedforwardJ2;

				motor[joint1] = inputJ1;
				motor[joint2] = inputJ2;
			}
			motor[joint1] = 0;
			motor[joint2] = 0;
			wait1Msec(200);
		}
		wait1Msec(3000);
	}

	return;
}
