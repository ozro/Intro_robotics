#pragma config(Motor,  motorA,          joint1,        tmotorNXT, PIDControl, encoder)
#pragma config(Motor,  motorB,          joint2,        tmotorNXT, PIDControl, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

float wpth1[3][6] = {{90,45,-120,15,30,120},{0,0,0,0,0,0},{0,0,0,0,0,0}};
int wpth2[3][6] = {{0,0,0,0,0,0},{0,0,0,0,0,0},{0,0,0,0,0,0}};
int num_waypoints = 6;

int joint1Strength = 1;
int joint2Strength = 1;
task main()
{
	nMotorEncoder[joint1] = 0;
	nMotorEncoder[joint2] = 0;
	for(int j = 0; j<3; j++)
	{
		for(int i = 0; i < num_waypoints; i++)
		{
			int goalth1 = 5*wpth1[j][i]+nMotorEncoder[joint1];
			int goalth2 = wpth2[j][i]+nMotorEncoder[joint2];

			int errorth1 = (goalth1 - nMotorEncoder[joint1])/5;
			int lastErrorth1 = (goalth1 - nMotorEncoder[joint1])/5;
			int sumErrorth1 = 0;

			int errorth2 = goalth2 - nMotorEncoder[joint2];
			int lastErrorth2 = goalth2 - nMotorEncoder[joint2];
			int sumErrorth2 = 0;
			clearTimer(T1);

			while(errorth1 !=  0 || abs(errorth2) != 0)
			{

				int dt = time1[T1];

				if(dt == 0){
					continue;
				}
				clearTimer(T1);

				errorth1 = (goalth1 - nMotorEncoder[joint1])/5;
				errorth2 = goalth2 - nMotorEncoder[joint2];

				float d_errorth1 = (errorth1-lastErrorth1)/dt;
				float d_errorth2 = (errorth2-lastErrorth2)/dt;

				sumErrorth1 += errorth1;
				sumErrorth2 += errorth2;

				lastErrorth1 = errorth1;
				lastErrorth2 = errorth2;

				float kP1 = 0.6;
				float kD1 = 0.5;
				float kI1 = 0.001;

				float kP2 = 0.6;
				float kD2 = 0.05;
				float kI2 = 0.002;

				float signalJ1 = kP1 * errorth1 + kD1 * d_errorth1 + kI1 * sumErrorth1;
				float signalJ2 = kP2 * errorth2 + kD2 * d_errorth2 + kI2 * sumErrorth2;

				int feedforwardJ1 = cos(nMotorEncoder[joint1]/5);
				int feedforwardJ2 = cos(nMotorEncoder[joint2]);

				int flatFFJ1 = 10;
				int flatFFJ2 = 2;

				int inputJ1 = signalJ1 * joint1Strength + feedforwardJ1+sgn(errorth1) * flatFFJ1;
				int inputJ2 = signalJ2 * joint2Strength + feedforwardJ2+sgn(errorth2) * flatFFJ2;

				nxtDisplayCenteredTextLine(3, "Error: %d", errorth1/5);
				nxtDisplayCenteredTextLine(4, "Joint1: %d", nMotorEncoder[joint1]/5);
				nxtDisplayCenteredTextLine(5, "Joint2: %d", nMotorEncoder[joint2]);

				motor[joint1] = inputJ1;
				motor[joint2] = inputJ2;
			}
			motor[joint1] = 0;
			motor[joint2] = 0;
			wait1Msec(2000);
		}
		return;
		wait1Msec(3000);
	}

	return;
}
