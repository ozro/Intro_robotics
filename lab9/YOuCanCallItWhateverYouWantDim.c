#pragma config(Motor,  motorA,          joint1,        tmotorNXT, openLoop, reversed, encoder)
#pragma config(Motor,  motorB,          joint2,        tmotorNXT, openLoop, reversed, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

int wpth1[3][4] = {{0,9*5,0,0},{0,16*5,0,0},{0,65*5,0,9*5}}; //Times 5
int wpth2[3][4] = {{106.5*1.67,0,0,0},{-30*1.67,0,0,0},{-115*1.67,0,-124*1.67,0}}; // Times 1.67
int num_waypoints = 4;

int joint1Strength = 1;
int joint2Strength = 1;
task main()
{
	nMotorEncoder[joint1] = 0;
	nMotorEncoder[joint2] = 0;
	int goalth1 = 0;
	int goalth2 = 0;
	for(int j = 0; j<3; j++)
	{
		for(int i = 0; i < num_waypoints; i++)
		{
			goalth1 = wpth1[j][i]+goalth1;
			goalth2 = wpth2[j][i]+goalth2;

			float errorth1 = (goalth1 - nMotorEncoder[joint1]);
			float lastErrorth1 = (goalth1 - nMotorEncoder[joint1]);
			int sumErrorth1 = 0;

			float errorth2 = goalth2 - nMotorEncoder[joint2];
			float lastErrorth2 = goalth2 - nMotorEncoder[joint2];
			int sumErrorth2 = 0;
			clearTimer(T1);

			while(abs(errorth1/5) > 3 || abs(errorth2/1.67) > 3)
			{

				int dt = time1[T1];

				if(dt == 0){
					continue;
				}
				clearTimer(T1);

				errorth1 = (goalth1 - nMotorEncoder[joint1]);
				errorth2 = goalth2 - nMotorEncoder[joint2];

				float d_errorth1 = (errorth1-lastErrorth1)/dt;
				float d_errorth2 = (errorth2-lastErrorth2)/dt;

				sumErrorth1 += errorth1;
				sumErrorth2 += errorth2;

				lastErrorth1 = errorth1;
				lastErrorth2 = errorth2;

				float kP1 = 1.3;
				float kD1 = 0;
				float kI1 = 0.0;

				float kP2 = 1;
				float kD2 = 0;
				float kI2 = 0.0;

				float signalJ1 = kP1 * errorth1 + kD1 * d_errorth1 + kI1 * sumErrorth1;
				float signalJ2 = kP2 * errorth2 + kD2 * d_errorth2 + kI2 * sumErrorth2;

				int feedforwardJ1 = cos(nMotorEncoder[joint1]/5)*45;
				int feedforwardJ2 = cos(nMotorEncoder[joint2]/1.67)*5;

				int flatFFJ1 = 24;
				int flatFFJ2 = 8;

				int inputJ1 = signalJ1 * joint1Strength + feedforwardJ1+sgn(errorth1) * flatFFJ1;
				int inputJ2 = signalJ2 * joint2Strength + feedforwardJ2+sgn(errorth2) * flatFFJ2;


				nxtDisplayCenteredTextLine(1, "Goal1: %f", goalth1/5);
				nxtDisplayCenteredTextLine(2, "Error1: %f", errorth1/5);
				nxtDisplayCenteredTextLine(3, "Goal2: %f", goalth2/1.67);
				nxtDisplayCenteredTextLine(4, "Error2: %f", errorth2/1.67);
				nxtDisplayCenteredTextLine(5, "Joint1: %f", nMotorEncoder[joint1]/5 );
				nxtDisplayCenteredTextLine(6, "Joint2: %f", nMotorEncoder[joint2]/1.67);

				motor[joint1] = inputJ1;
				motor[joint2] = inputJ2;
			}
			motor[joint1] = 0;
			motor[joint2] = 0;
			wait1Msec(200);
		}
		wait1Msec(4000);
	}

	return;
}
