#pragma config(Motor,  motorA,           ,             tmotorNXT, PIDControl, reversed, encoder)
#pragma config(Motor,  motorB,          motorLeft,     tmotorNXT, PIDControl, reversed, encoder)
#pragma config(Motor,  motorC,          motorRight,    tmotorNXT, PIDControl, reversed, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/**********************************************
* Lab 3 : Starter code
* Written by Kaushik Viswanathan,
* Modified by Allan Wang (Jan 2017)

* Feel free to modify any part of these codes.
**********************************************/

//Global variables - you will need to change some of these
//Robot's positions
float robot_X = 0, robot_Y = 0, robot_TH = 0;

//Wheel diameter and circumference in mm
const float WHEEL_DIAMETER = 55.2;
const float WHEEL_CIRCUMFERENCE = WHEEL_DIAMETER * 3.14159265;
//Distance between wheels in mm
const float WHEEL_DISTANCE = 134;
//Number of ticks per mm
const float TICKS_PER_MM = 360/WHEEL_CIRCUMFERENCE;

int velocityUpdateInterval = 5;
int PIDUpdateInterval = 2;

//Change these during demo
//float inputStraight[2] = {12*25.4, 36*25.4}; // in mm
//float inputTurn[2] = {0, 0}; // in degrees, negative means clockwise rotation
//float inputStraight[2] = {12*sqrt(2)*25.4, 12*25.4};
//float inputTurn[2] = {45, 45};
//float wp_x[7] = {25.4*1.68, 25.4*8.12, 25.4*14.56, 25.4*14.56, 25.4*0.42, 25.4*0.42, 25.4*-0.14};
//float wp_y[7] = {25.4*-1.68, 25.4*-1.68, 25.4*4.76, 25.4*8.26, 25.4*22.4, 25.4*23.52, 25.4*24.08};
//float wp_x[9] = {25.4*1.82, 25.4*8.12, 25.4*14.84, 25.4*14.84, 25.4*22.26, 25.4*22.26, 25.4*12.46, 25.4*5.46, 25.4*-0.14};
//float wp_y[9] = {25.4*-1.82, 25.4*-1.82, 25.4*4.9, 25.4*9.38, 25.4*16.8, 25.4*19.88, 25.4*29.68, 25.4*29.68, 25.4*24.08};
//float wp_x[11] = {25.4*1.89, 25.4*8.33, 25.4*14.84, 25.4*14.84, 25.4*22.4, 25.4*22.4, 25.4*10.29, 25.4*4.06, 25.4*1.75, 25.4*0, 25.4*-0.07};
//float wp_y[11] = {25.4*-1.89, 25.4*-1.89, 25.4*4.62, 25.4*9.1, 25.4*16.66, 25.4*19.95, 25.4*32.06, 25.4*25.83, 25.4*25.83, 25.4*24.08, 25.4*24.08};
//float wp_x[12] = {135.13,647.19,1052.6,1056.1,1141.5,1141.5,1116.6,1077.5,974.34,896.11,67.564,-3.556};
//float wp_y[12] = {-74.676,-56.896,348.49,348.49,433.83,526.29,561.85,604.52,707.64,721.87,675.64,608.08};
//float wp_x[7] = {138.68,650.75,1137.9,1134.4,889,14.224,-3.556};
//float wp_y[7] = {-71.12,-53.34,433.83,544.07,789.43,625.86,608.08};
//float wp_x[5] = {469.39,1070.4,1180.6,871.22,-3.556};
//float wp_y[5] = {-202.69,376.94,487.17,796.54,608.08};
//float wp_x[3] = {12*25.4, 24*25.4,0};
//float wp_y[3] = {12*25.4, -36*25.4,0};
//float wp_x[7] = {515.62,1137.9,1127.3,963.68,536.96,39.116,-3.556};
//float wp_y[7] = {103.12,92.456,-238.25,-366.27,-739.65,-654.3,-611.63};
float wp_x[1] ={12*25.4};
float wp_y[1]= {12*25.4};
//float wp_x[3] = {12*25.4, 0, 0};
//float wp_y[3] = {-12*25.4, -12*25.4, 0};
//float wp_x[3] = {12*25.4,0,0};
//float wp_y[3] = {-12*25.4, -12*25.4,0};
//float wp_x[4] = {152.91,643.64,1137.9,1216.2};
//float wp_y[4] = {-53.34,-35.56,458.72,608.08};
//float wp_x[5] = {309.37,664.97,1180.6,867.66,-3.556};
//float wp_y[5] = {-145.8,-32.004,483.62,796.54,604.52};
//float wp_x[8] = {508.51,960.12,1130.8,1123.7,967.23,480.06,10.668,-3.556};
//float wp_y[8] = {110.24,99.568,-71.12,-330.71,-330.71,-803.66,-618.74,-608.08};
int num_waypoints =1;
float motorPower = 1;
/*****************************************
* Complete this function so that it
* continuously updates the robot's position
*****************************************/
task dead_reckoning()
{
	clearTimer(T1);
	float last_enc_L = nMotorEncoder[motorLeft];
	float last_enc_R = nMotorEncoder[motorRight];

	while(1)
	{
		//
		// Fill in code for numerical integration / position estimation here
		//
		int dt = time1[T1];
		if(dt == 0)
		{
			continue;
		}
		clearTimer(T1);

		int dEncL = nMotorEncoder[motorLeft] - last_enc_L;
		int dEncR = nMotorEncoder[motorRight] - last_enc_R;
		last_enc_L = nMotorEncoder[motorLeft];
		last_enc_R = nMotorEncoder[motorRight];

		//update robot_x and robot_Y
		float dispL = dEncL / TICKS_PER_MM;
		float dispR = dEncR / TICKS_PER_MM;
		float disp = (dispL + dispR)/2;
		float angDisp = (dispR - dispL)/WHEEL_DISTANCE;
		robot_TH = robot_TH + angDisp/2;
		robot_X = robot_X + cos(robot_TH)*disp;
		robot_Y = robot_Y + sin(robot_TH)*disp;
		robot_TH = robot_TH + angDisp/2;

		/*Code that plots the robot's current position and also prints it out as text*/
		nxtSetPixel(50 + (int)(100.0 * robot_X), 32 + (int)(100.0 * robot_Y));
		nxtDisplayTextLine(0, "X: %f", robot_X);
		nxtDisplayTextLine(1, "Y: %f", robot_Y);
		nxtDisplayTextLine(2, "t: %f", robot_TH / PI * 180);
		nxtDisplayTextLine(3, "d: %f", sqrt(pow(robot_X - 0, 2) + pow(robot_Y - 0, 2)));

		wait1Msec(velocityUpdateInterval);
	}
}

/**********************************************
* Function that judges if two floats are equal
**********************************************/
bool equal(float a, float b) {
	float epsilon = WHEEL_DIAMETER/2*0.0349/WHEEL_DISTANCE;
	if (abs(a-b) < epsilon) {
		return true;
		} else {
		return false;
	}
}

bool equal2(float a, float b) {
	float epsilon = .00025;
	if (abs(a-b) < epsilon) {
		return true;
		} else {
		return false;
	}
}

/*****************************************
* Main function - Needs changing
*****************************************/
task main()
{

	/* Reset encoders and turn on PID control */
	nMotorEncoder[motorRight] = 0;
	nMotorEncoder[motorLeft] = 0;
	nMotorPIDSpeedCtrl[motorRight] = mtrSpeedReg;
	nMotorPIDSpeedCtrl[motorLeft] = mtrSpeedReg;
	nPidUpdateInterval = PIDUpdateInterval;

	nMaxRegulatedSpeedNxt = 500;
	//draw_grid();
	startTask(dead_reckoning);
	for(int i = 0; i < num_waypoints; i++)
	{

		//		goalStraight = inputStraight[i];

		//goalTurn = inputTurn[i] / 180.0 * PI * -1;

		float goal_x = wp_x[i];
		float goal_y = wp_y[i];

		float goalTurn = atan2(goal_y-robot_Y, goal_x-robot_X)-robot_TH;
		if (goalTurn > PI)
			goalTurn = goalTurn - 2*PI;
		if (goalTurn < -PI)
			goalTurn = goalTurn + 2*PI;
		float goalStraight = sqrt((goal_x-robot_X)*(goal_x-robot_X) + (goal_y-robot_Y)*(goal_y-robot_Y));
		nxtDisplayCenteredTextLine(4, "GoalTurn: %f", goalTurn/PI*180);
		nxtDisplayCenteredTextLine(5, "GoalStra: %f", goalStraight);

		// PID for turn control
		float error = goalTurn;
		float last_error = goalTurn;
		float sum_error = 0;
		clearTimer(T1);

		while (!equal(error,0)) {

			//nxtDisplayCenteredTextLine(4, "Goal Turn: %f", goalTurn);
			int dt = time1[T1];
			if(dt == 0){
				continue;
			}
			clearTimer(T1);

			error =atan2(goal_y-robot_Y, goal_x-robot_X)-robot_TH;
 		if (error > PI)
			error = error - 2*PI;
		if (error < -PI)
			error = error + 2*PI;
			float d_error = (error-last_error)/dt;
			sum_error += error;
			last_error = error;
			float kI = 0;
			float kP = 1;
			float kD = 1;
			float signal = kP * error + kD * d_error + kI * sum_error;

		//	nxtDisplayCenteredTextLine(5, "error: %f", error);


				motor[motorRight] = signal * motorPower + sgn(error)*10;
				motor[motorLeft] = signal  *-1* motorPower - sgn(error)*10;

		}
		//nxtDisplayCenteredTextLine(7, "");
		motor[motorRight] = 0;
		motor[motorLeft] = 0;

wait1Msec(250);
		float start_X = robot_X;
		float start_Y = robot_Y;

		// PID for straight control
		error = goalStraight;
		last_error = goalStraight;
		sum_error = 0;
		clearTimer(T1);
		clearTimer(T2);

		while(error>0){//while (error>40) {
			//nxtDisplayCenteredTextLine(6, "Estraight: %f", error);
			//nxtDisplayCenteredTextLine(4, "Goal Straight: %f", goalStraight);
			int dt = time1[T1];

			if(dt == 0){
				continue;
			}
			clearTimer(T1);

			float actual =  sqrt(pow(robot_X - start_X, 2) + pow(robot_Y - start_Y, 2));
			float supposed =  sqrt(pow(goal_x - start_X, 2) + pow(goal_Y - start_Y, 2));
			error = supposed-actual;
				nxtDisplayCenteredTextLine(6, "SError: %f", error);
			float d_error = (error-last_error)/dt;
			sum_error += error;
			last_error = error;
			//float kP = 1;
			float kI = 0;
			//float kP = 0;
			//float kD = 0;
			float kP = .5;
			float kD = 1;

			float signal = kP * error + kD * d_error + kI * sum_error;
			if (signal > 50)
				signal = 50;


			nxtDisplayCenteredTextLine(5, "SSignal: %f", signal);

			int ramp_dt = time1[T2];
			float ramp_time = 1000.0;
			int feedforward = 60;
			int input = signal * motorPower + sgn(error) * feedforward;
			if (ramp_dt < ramp_time){
				input = input * (1- (ramp_time - ramp_dt)/ramp_time);
				nxtDisplayCenteredTextLine(7, "ramp_dt: %d", input);
			}

			motor[motorRight] = input;
			motor[motorLeft] = input;
		}
	//nxtDisplayCenteredTextLine(7, "Outloop");

			motor[motorRight] = 0;
	motor[motorLeft] = 0;
		wait1Msec(250);
	}

	//nNxtButtonTask  = 0;
	//while(nNxtButtonPressed != kExitButton) {}
}
