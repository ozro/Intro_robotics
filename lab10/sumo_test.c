#pragma config(Sensor, S1,     light,          sensorLightActive)
#pragma config(Sensor, S2,     touch,          sensorTouch)
#pragma config(Sensor, S3,     sonar,          sensorSONAR)
#pragma config(Sensor, S4,     sound,          sensorSoundDB)
#pragma config(Motor,  motorA,          leftMotor,     tmotorNXT, openLoop, encoder)
#pragma config(Motor,  motorB,          rightMotor,    tmotorNXT, openLoop, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/* Two states: 1. Look, 2. Charge, 3. Recover, 4. Push back the offender
*/
int lookMotorPower = 100;
int chargeMotorPower = 100;
int gameState = 1;
int lightThreshold = 56;
int sonarThreshold = 80;

bool notSeen = false;
bool backwardFlag = false;
bool startLookFlag = false;
int startTime = 1000;
int rotation = 1;

task main()
{
	rotation = rand()%2*2-1;
	lookMotorPower = rotation*lookMotorPower;
	while(1) {
		nxtDisplayCenteredTextLine(1, "sonar: %f", SensorValue[sonar]);
		nxtDisplayCenteredTextLine(2, "touch: %f", SensorValue[touch]);
		nxtDisplayCenteredTextLine(3, "light: %f", SensorValue[light]);
		nxtDisplayCenteredTextLine(4, "state: %d", gameState);
		motor[motorC] = SensorValue[sound];
		// When search for opponent, keep turning until find the opponent
		if (gameState == 1){
			// If at the edge, recover first
			if (SensorValue[light] >= lightThreshold) {
				gameState = 3;
				motor[leftMotor] = 0;
				motor[rightMotor] = 0;
				startTime = 1000;
				continue;
			}
			// Push back the offender if getting pushed
			if (SensorValue[touch] == 1){
				gameState = 4;
				motor[leftMotor] = 0;
				motor[rightMotor] = 0;
				startTime = 1000;
				continue;
			}
			// Initially rotate for 0.5 seconds.
			// If have been searching in the same direction for more than 3 seconds,
			// switch the direction
			if(!startLookFlag)
			{
				clearTimer(T4);
				startLookFlag = true;
			}
			else
			{
				if (time1(T4)>=startTime)
				{
					lookMotorPower = -lookMotorPower;
					startTime = 4000;
					startLookFlag = false;
				}
			}


			// Find the opponent in front
			if(SensorValue[sonar] < sonarThreshold){
				gameState = 2;
				motor[leftMotor] = 0;
				motor[rightMotor] = 0;
				startTime = 1000;
				continue;
			}
			motor[leftMotor] = lookMotorPower;
			motor[rightMotor] = -lookMotorPower;
		}
		// When in charge mode, want go forward to attack
		if (gameState == 2) {
			if (SensorValue[light] >= lightThreshold) {
				gameState = 3;
				motor[leftMotor] = 0;
				motor[rightMotor] = 0;
				continue;
			}
			// If the opponent leaves, go back to search
			if(SensorValue[sonar] > sonarThreshold){
				if (!notSeen) {
					clearTimer(T2);
					notSeen = true;
				}
				else if (time1(T2) > 1000){
					notSeen = false;
					gameState = 1;
					rotation = rand()%2*2-1;
					lookMotorPower = rotation*lookMotorPower;
					continue;
				}
			}
			motor[leftMotor] = chargeMotorPower;
			motor[rightMotor] = chargeMotorPower;
		}
		// When in recover mode, first back up and then turn around and go for certain distance
		if (gameState == 3) {
			if (!backwardFlag) {
				clearTimer(T1);
				backwardFlag = true;
			}
			else {
				if (time1[T1] <= 500) {
					motor[leftMotor] = -chargeMotorPower;
					motor[rightMotor] = -chargeMotorPower;
				}
				else if (time1[T1] <= 1000) {
					motor[leftMotor] = lookMotorPower;
					motor[rightMotor] = -lookMotorPower;
				}
				else {
					backwardFlag = false;
					motor[leftMotor] = 0;
					motor[rightMotor] = 0;
					rotation = rand()%2*2-1;
					lookMotorPower = rotation*lookMotorPower;
					gameState = 1;
				}
			}
		}
		// When someone is pushing us from behind, push back
		if (gameState == 4) {
			if (SensorValue[touch] == 1) {
			motor[leftMotor] = -chargeMotorPower;
			motor[rightMotor] = -chargeMotorPower;
			}
			else {
				gameState = 1;
				motor[leftMotor] = lookMotorPower;
				motor[rightMotor] = -lookMotorPower;
			}
		}
	}
}
