#pragma config(Sensor, S1,     light,          sensorLightActive)
#pragma config(Sensor, S2,     touch,          sensorTouch)
#pragma config(Sensor, S3,     sonar,          sensorSONAR)
#pragma config(Sensor, S4,     sound,          sensorSoundDB)
#pragma config(Motor,  motorA,          leftMotor,     tmotorNXT, openLoop, encoder)
#pragma config(Motor,  motorB,          rightMotor,    tmotorNXT, openLoop, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/* Two states: 1. Look, 2. Charge, 3. Recover, 4. Push back the offender
*/
int lookMotorPower = 50;
int chargeMotorPower = 100;
int gameState = 1;
int lightThreshold = 65;
int sonarThreshold = 60;

bool switchSearchDir = false;
bool notSeen = false;
bool backwardFlag = false;

task main()
{
	while(1) {
		nxtDisplayCenteredTextLine(1, "sonar: %f", SensorValue[sonar]);
		nxtDisplayCenteredTextLine(2, "touch: %f", SensorValue[touch]);
		nxtDisplayCenteredTextLine(3, "light: %f", SensorValue[light]);
		nxtDisplayCenteredTextLine(4, "state: %d", gameState);
		motor[motorC] = SensorValue[sound];
		// When search for opponent, keep turning until find the opponent
		if (gameState == 1){
			// If at the edge, recover first
			if (SensorValue[light] >= lightThreshold) {
				gameState = 3;
				motor[leftMotor] = 0;
				motor[rightMotor] = 0;
				continue;
			}
			// Push back the offender if getting pushed
			if (SensorValue[touch] == 1){
				gameState = 4;
				motor[leftMotor] = 0;
				motor[rightMotor] = 0;
				continue;
			}

			// If have been searching in the same direction for more than 3 seconds,
			// switch the direction
			if (!switchSearchDir) {
				switchSearchDir = true;
				clearTimer(T3);
			}
			else {
				if (time1(T3} >= 3000) {
					motor[leftMotor] = -motor[leftMotor];
					motor[rightMotor] = -motor[rightMotor];
					switchSearchDir = false
				}
			}

			// Find the opponent in front
			if(SensorValue[sonar] < sonarThreshold){
				gameState = 2;
				playSound(soundBeepBeep);
				motor[leftMotor] = 0;
				motor[rightMotor] = 0;
				continue;
			}
			motor[leftMotor] = lookMotorPower;
			motor[rightMotor] = -lookMotorPower;
		}
		// When in charge mode, want go forward to attack
		if (gameState == 2) {
			if (SensorValue[light] >= lightThreshold) {
				gameState = 3;
				motor[leftMotor] = 0;
				motor[rightMotor] = 0;
				continue;
			}
			// If the opponent leaves, go back to search
			if(SensorValue[sonar] > sonarThreshold){
				if (!notSeen) {
					clearTimer(T2);
					notSeen = true;
				}
				else if (time1(T2) > 1000){
					notSeen = false;
					gameState = 1;
					playSound(soundDownwardTones);
					continue;
				}
			}
			motor[leftMotor] = chargeMotorPower;
			motor[rightMotor] = chargeMotorPower;
		}
		// When in recover mode, first back up and then turn around
		if (gameState == 3) {
			if (!backwardFlag) {
				clearTimer(T1);
				backwardFlag = true;
			}
			else {
				if (time1[T1] <= 500) {
					motor[leftMotor] = -chargeMotorPower;
					motor[rightMotor] = -chargeMotorPower;
				}
				else {
					backwardFlag = false;
					motor[leftMotor] = 0;
					motor[rightMotor] = 0;
					gameState = 1;
				}
			}
		}
		// When someone is pushing us from behind, push back
		if (gameState == 4) {
			if (SensorValue[touch] == 1) {
			motor[leftMotor] = -chargeMotorPower;
			motor[rightMotor] = -chargeMotorPower;
			}
			else {
				gameState = 1;
				motor[leftMotor] = lookMotorPower;
				motor[rightMotor] = -lookMotorPower;
			}
		}
	}
}
