#pragma config(Sensor, S1,     backLight,      sensorLightActive)
#pragma config(Sensor, S4,     frontLight,     sensorLightActive)
#pragma config(Motor,  motorA,          rightMotor,    tmotorNXT, PIDControl, driveRight, encoder)
#pragma config(Motor,  motorB,          leftMotor,     tmotorNXT, PIDControl, driveLeft, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/**********************************************
* Lab 4 : Starter code
* Written by Kaushik Viswanathan,
* Modified by Allan Wang (Jan 2017)

* Feel free to modify any part of these codes.

// This is the calibration for board B, facing down, parallel and close to the right side
**********************************************/
//Global PID Variables
float last_error;
float sum_error = 0;
int PIDUpdateInterval = 2;

//Set parameters
//const int LOW_THRESHOLD = 36;
//const int HIGH_THRESHOLD = 66;
//Brightness value at the "gray zone" between line and background
//const int THRESHOLD = (LOW_THRESHOLD + HIGH_THRESHOLD)/2;
const float MOTOR_POWER = 1;	 //Base motor power to control the speed
const float UPDATE_INTERVAL = 1; //Delay updates by x miliseconds
//const float UPDATE_INTERVAL = .8; //Delay updates by x miliseconds

// Parameters for facing left, parallel to length
const float kP = .48;
const float kD = 6;
const float kI = .006;


/*****************************************
* Main function - Needs changing
*****************************************/

/*task main()
{
	motor[motorA] = MOTOR_POWER;
}*/

task main()
{
	/* Reset encoders and turn on PID control */
	nMotorEncoder[rightMotor] = 0;
	nMotorEncoder[leftMotor] = 0;
	nMotorPIDSpeedCtrl[rightMotor] = mtrSpeedReg;
	nMotorPIDSpeedCtrl[leftMotor] = mtrSpeedReg;
	nPidUpdateInterval = PIDUpdateInterval;

	nMaxRegulatedSpeedNxt = 250;
	//Wait for sensor initialization
	wait1Msec(50);

	clearTimer(T1);

	// Start balancing
	clearTimer(T1);
	while(1){

		int dt = time1[T1];
		clearTimer(T1);
		if(dt == 0) {
			continue;
		}

		//PID
		// Facing left, parallel to length should have offset -15
		// Facing right, parallel to length should have offset +45
		// Facing down, parallel to the width should have offset 0
		float error_offset = 0;
		float error = SensorRaw(frontLight) - SensorRaw(backLight) + error_offset; //Positive error = tilting forward. Negative error = tilting backward
		float d_error = (error-last_error)/dt;
		sum_error += error;
		last_error = error;

		float signal = kP * error + kD * d_error + kI * sum_error;
		nxtDisplayCenteredTextLine(2, "Error: %f", error);
		nxtDisplayCenteredTextLine(3, "Signal: %f", signal);

		// Update motors
		if(signal > 0){ //Tilting forward, need to move forward
			//float feedforward = .1*error;
			motor(leftMotor) = MOTOR_POWER * signal; //+ feedforward;
			motor(rightMotor) = motor(leftMotor); //Left Motor
		}
		else if (signal < 0) { //Tilting backward, need to move backward
			float feedforward = 0;
			motor(leftMotor) = MOTOR_POWER * signal + feedforward;
			motor(rightMotor) = motor(leftMotor); //Left Motor
		}
		else {
			motor(leftMotor) = 0;
			motor(rightMotor) = 0;
		}
		nxtDisplayCenteredTextLine(4, "Left motor: %f", motor(leftMotor));
		nxtDisplayCenteredTextLine(5, "Right motor: %f", motor(rightMotor));
		wait1Msec(UPDATE_INTERVAL);
	}
}
