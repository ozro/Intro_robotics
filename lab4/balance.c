#pragma config(Sensor, S1,     backLight,      sensorLightActive)
#pragma config(Sensor, S4,     frontLight,     sensorLightActive)
#pragma config(Motor,  motorA,          rightMotor,    tmotorNXT, PIDControl, driveRight, encoder)
#pragma config(Motor,  motorB,          leftMotor,     tmotorNXT, PIDControl, driveLeft, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/**********************************************
* Lab 4: Control

This is the calibration for board B, facing down, parallel and close to the right side
**********************************************/
//Global PID Variables
float last_error;
float sum_error = 0;
int PIDUpdateInterval = 2;

//Set parameters
const float MOTOR_POWER = 1;	 //Base motor power to control the speed
const float UPDATE_INTERVAL = 1; //Delay updates by x miliseconds

// Parameters also work for facing left, parallel to length on board A
const float kP = .48;
const float kD = 6;
const float kI = .006;


/*****************************************
* Main function
*****************************************/

task main()
{
	/* Reset encoders and turn on PID control */
	nMotorEncoder[rightMotor] = 0;
	nMotorEncoder[leftMotor] = 0;
	nMotorPIDSpeedCtrl[rightMotor] = mtrSpeedReg;
	nMotorPIDSpeedCtrl[leftMotor] = mtrSpeedReg;
	nPidUpdateInterval = PIDUpdateInterval;

	nMaxRegulatedSpeedNxt = 250;
	//Wait for sensor initialization
	wait1Msec(50);

	clearTimer(T1);

	// Start balancing
	clearTimer(T1);
	while(1){
		int dt = time1[T1];
		clearTimer(T1);
		if(dt == 0) {
			continue;
		}
		//PID
		// Facing left, parallel to length should have offset -15
		// Facing right, parallel to length should have offset +45
		// Facing down, parallel to the width should have offset 0
		float error_offset = 0;
		//Positive error = tilting forward. Negative error = tilting backward
		float error = SensorRaw(frontLight) - SensorRaw(backLight) + error_offset;
		float d_error = (error-last_error)/dt;
		sum_error += error;
		last_error = error;

		float signal = kP * error + kD * d_error + kI * sum_error;
		nxtDisplayCenteredTextLine(2, "Error: %f", error);
		nxtDisplayCenteredTextLine(3, "Signal: %f", signal);

		// Update motors
		if(signal > 0){ //Tilting forward, need to move forward
			motor(leftMotor) = MOTOR_POWER * signal;
			motor(rightMotor) = motor(leftMotor);
		}
		else if (signal < 0) { //Tilting backward, need to move backward
			motor(leftMotor) = MOTOR_POWER * signal;
			motor(rightMotor) = motor(leftMotor);
		}
		else {
			motor(leftMotor) = 0;
			motor(rightMotor) = 0;
		}
		nxtDisplayCenteredTextLine(4, "Left motor: %f", motor(leftMotor));
		nxtDisplayCenteredTextLine(5, "Right motor: %f", motor(rightMotor));
		wait1Msec(UPDATE_INTERVAL);
	}
}
