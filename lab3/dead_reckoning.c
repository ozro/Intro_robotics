#pragma config(Motor,  motorA,          motorRight,    tmotorNXT, PIDControl, encoder)
#pragma config(Motor,  motorB,          motorLeft,     tmotorNXT, PIDControl, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/**********************************************
* Lab 3 : Starter code
* Written by Kaushik Viswanathan,
* Modified by Allan Wang (Jan 2017)

* Feel free to modify any part of these codes.
**********************************************/

//Global variables - you will need to change some of these
//Robot's positions
float robot_X = 0.0, robot_Y = 0.0, robot_TH = 0.0;

//Wheel diameter and circumference in mm
const float WHEEL_DIAMETER = 55;
const float WHEEL_CIRCUMFERENCE = WHEEL_DIAMETER * 3.14159265;
//Distance between wheels in mm
const float WHEEL_DISTANCE = 157.5;
//Number of ticks per mm
const float TICKS_PER_MM = 360/WHEEL_CIRCUMFERENCE;

int velocityUpdateInterval = 5;
int PIDUpdateInterval = 2;

//Change these during demo
//float inputStraight[2] = {12*25.4, 36*25.4}; // in mm
//float inputTurn[2] = {0, 0}; // in degrees, negative means clockwise rotation
float inputStraight[2] = {8*25.4, 20*25.4};
float inputTurn[2] = {90, -60};
float motorPower = 1;

/*****************************************
* Complete this function so that it
* continuously updates the robot's position
*****************************************/
task dead_reckoning()
{
	clearTimer(T1);
	float last_enc_L = nMotorEncoder[motorLeft];
	float last_enc_R = nMotorEncoder[motorRight];

	while(1)
	{
		//
		// Fill in code for numerical integration / position estimation here
		//
		int dt = time1[T1];
		if(dt == 0)
		{
			continue;
		}
		clearTimer(T1);

		int dEncL = nMotorEncoder[motorLeft] - last_enc_L;
		int dEncR = nMotorEncoder[motorRight] - last_enc_R;
		last_enc_L = nMotorEncoder[motorLeft];
		last_enc_R = nMotorEncoder[motorRight];

		//update robot_x and robot_Y
		float dispL = dEncL / TICKS_PER_MM;
		float dispR = dEncR / TICKS_PER_MM;
		float disp = (dispL + dispR)/2;
		float angDisp = (dispL - dispR)/WHEEL_DISTANCE;
		robot_TH = robot_TH + angDisp/2;
		robot_X = robot_X + cos(robot_TH)*disp;
		robot_Y = robot_Y + sin(robot_TH)*disp;
		robot_TH = robot_TH + angDisp/2;

		/*Code that plots the robot's current position and also prints it out as text*/
		nxtSetPixel(50 + (int)(100.0 * robot_X), 32 + (int)(100.0 * robot_Y));
		nxtDisplayTextLine(0, "X: %f", robot_X);
		nxtDisplayTextLine(1, "Y: %f", robot_Y);
		nxtDisplayTextLine(2, "t: %f", robot_TH / PI * 180);
		nxtDisplayTextLine(3, "d: %f", sqrt(pow(robot_X - 0, 2) + pow(robot_Y - 0, 2)));

		wait1Msec(velocityUpdateInterval);
	}
}

/*****************************************
* Function that draws a grid on the LCD
* for easier readout of whatever is plot
*****************************************/
void draw_grid()
{
	for(int i = 0; i < 65; i++)
	{
		nxtSetPixel(50, i);
		int grid5 = (i - 32) % 5;
		int grid10 = (i - 32) % 10;
		if(!grid5 && grid10)
		{
			for(int j = -2; j < 3; j++)
			{
				nxtSetPixel(50 + j, i);
			}
		}
		else if(!grid10)
		{
			for(int j = -4; j < 5; j++)
			{
				nxtSetPixel(50 + j, i);
			}
		}
	}
	for(int i = 0; i < 101; i++)
	{
		nxtSetPixel(i, 32);
		int grid5 = (i - 100) % 5;
		int grid10 = (i - 100) % 10;
		if(!grid5 && grid10)
		{
			for(int j = -2; j < 3; j++)
			{
				nxtSetPixel(i, 32 + j);
			}
		}
		else if(!grid10)
		{
			for(int j = -4; j < 5; j++)
			{
				nxtSetPixel(i, 32 + j);
			}
		}
	}
}

/**********************************************
* Function that judges if two floats are equal
**********************************************/
bool equal(float a, float b) {
	float epsilon = 0.01;
	if (abs(a-b) < epsilon) {
		return true;
		} else {
		return false;
	}
}

/*****************************************
* Main function - Needs changing
*****************************************/
task main()
{

	/* Reset encoders and turn on PID control */
	nMotorEncoder[motorRight] = 0;
	nMotorEncoder[motorLeft] = 0;
	nMotorPIDSpeedCtrl[motorRight] = mtrSpeedReg;
	nMotorPIDSpeedCtrl[motorLeft] = mtrSpeedReg;
	nPidUpdateInterval = PIDUpdateInterval;

	float goalStraight = 0;
	float goalTurn = 0;
	float start_X = 0;
	float start_Y = 0;
	float start_TH = 0;

	//draw_grid();
	startTask(dead_reckoning);

	for(int i = 0; i < 2; i++)
	{
		goalStraight = inputStraight[i];

		goalTurn = inputTurn[i] / 180.0 * PI * -1;

		start_TH = robot_TH;

		// PID for turn control
		float error = goalTurn;
		float last_error = goalTurn;
		clearTimer(T1);

		while (!equal(error, 0)) {
			nxtDisplayCenteredTextLine(6, "Error: %f", error);
			nxtDisplayCenteredTextLine(4, "Goal Turn: %f", goalTurn);
			int dt = time1[T1];
			if(dt == 0){
				continue;
			}
			clearTimer(T1);

			float actual = robot_TH - start_TH;
			error = goalTurn - actual;
			float d_error = (error-last_error)/dt;
			last_error = error;
			float kP = 10;
			float kD = 5;
			float signal = kP * error + kD * d_error;

			nxtDisplayCenteredTextLine(5, "Signal: %f", signal);

			motor[motorRight] = signal * -1 * motorPower - sgn(signal)*20;
			motor[motorLeft] = signal * motorPower + sgn(signal)*20;
		}
		motor[motorRight] = 0;
		motor[motorLeft] = 0;
		wait1Msec(50);

		start_X = robot_X;
		start_Y = robot_Y;

		// PID for straight control
		error = goalStraight;
		last_error = goalStraight;
		clearTimer(T1);
		while (error>1) {

			nxtDisplayCenteredTextLine(4, "Goal Straight: %f", goalStraight);
			int dt = time1[T1];
			if(dt == 0){
				continue;
			}
			clearTimer(T1);

			float actual =  sqrt(pow(robot_X - start_X, 2) + pow(robot_Y - start_Y, 2));
			error = goalStraight - actual;
			float d_error = (error-last_error)/dt;
			last_error = error;
			//float kP = 1;
			//float kD = 5;
			float kP = 1;
			float kD = 8;
			float signal = kP * error + kD * d_error;

			nxtDisplayCenteredTextLine(5, "Signal: %f", signal);

			motor[motorRight] = signal * motorPower;
			motor[motorLeft] = signal * motorPower;
		}


		wait1Msec(50);
	}
	motor[motorRight] = 0;
	motor[motorLeft] = 0;
	nNxtButtonTask  = 0;
	while(nNxtButtonPressed != kExitButton) {}
}
